/*********************************************************************
Author: Roberto Bruttomesso <roberto.bruttomesso@gmail.com>

OpenSMT -- Copyright (C) 2009, Roberto Bruttomesso

OpenSMT is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSMT is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSMT. If not, see <http://www.gnu.org/licenses/>.
*********************************************************************/

#include "THandler.h"
#include "CoreSMTSolver.h"

#ifdef EXTERNAL_TOOL
#include <sys/wait.h>
#endif

//
// Return the MiniSAT Variable corresponding to
// the positive input enode. Creates the correspondence
// by adding a new MiniSAT variable, if it doesn't exists
//
Var THandler::enodeToVar( Enode * atm )
{
  assert( atm );
  assert( atm->isAtom( ) );
  assert( !atm->isTrue( ) );
  assert( !atm->isFalse( ) );

  if ( enode_id_to_var.size( ) <= (unsigned)atm->getId( ) )
    enode_id_to_var.resize( atm->getId( ) + 1, var_Undef );

  Var v = enode_id_to_var[ atm->getId( ) ];

  if ( v == var_Undef )
  {
    lbool state = l_Undef;
    // Inform core solver about the existence of this atom
    if ( atm->isTAtom( ) )
      state = core_solver.inform( atm );

    if ( state == l_Undef )
    {
      // There is no variable in MiniSAT for this enode
      // Create a new variable and store the correspondence

      // Assign custom polarity if any
      if ( atm->isTAtom( ) && atm->getPolarity( ) != l_Undef )
	v = solver.newVar( atm->getDecPolarity( ) == l_False );
      // Assign positive otherwise
      else
	v = solver.newVar( false );

      if ( atm->isTAtom( ) )
      {
	solver.setFrozen( v, true );
	tatoms ++;
      }
      else
	batoms ++;

      enode_id_to_var[ atm->getId( ) ] = v;

      if ( var_to_enode.size( ) <= (unsigned)v )
	var_to_enode.resize( v + 1, NULL );

      assert( var_to_enode[ v ] == NULL );
      var_to_enode[ v ] = atm;
    }
    else if ( state == l_False )
    {
      v = var_False;
    }
    else
    {
      v = var_True;
    }
  }

  assert( v != var_Undef );
  return v;
}

//
// Return the MiniSAT literal corresponding to
// the input enode literal. Creates the correspondence
// by adding a new MiniSAT variable, if it doesn't exists
//
Lit THandler::enodeToLit( Enode * elit )
{
  assert( elit );
  assert( elit->isLit( ) );

  bool negated = elit->isNot( );
  Enode * atm = negated ? elit->getCdr( )->getCar( ) : elit;
  Var v = enodeToVar( atm );
  return Lit( v, negated );
}

Enode * THandler::varToEnode( Var v )
{
  assert( v < (int)var_to_enode.size( ) );
  assert( var_to_enode[ v ] != NULL );
  return var_to_enode[ v ];
}

bool THandler::assertLits( )
{
  bool res = true;

  assert( checked_trail_size == stack.size( ) );
  assert( (int)stack.size( ) <= trail.size( ) );

  for ( int i = checked_trail_size ; i < trail.size( ) && res ; i ++ )
  {
    const Lit l = trail[ i ];
    const Var v = var( l );

    Enode * e = var_to_enode[ v ];
    stack.push_back( e );

    if ( v == var_True || v == var_False )
    {
      assert( v != var_True  || sign( l ) == false );
      assert( v != var_False || sign( l ) == true );
      continue;
    }

    if ( !e->isTAtom( ) )
      continue;

    // Push backtrack point
    core_solver.pushBacktrackPoint( );

    assert( !e->hasPolarity( ) );
    e->setPolarity( (sign( l ) ? l_False : l_True) );

    res = core_solver.assertLit( e );

#ifdef EXTERNAL_TOOL
    if ( !res ) verifyCallWithExternalTool( res, i );
#endif
  }

  checked_trail_size = stack.size( );
  assert( !res || trail.size( ) == (int)stack.size( ) );

  return res;
}

bool THandler::check( bool complete )
{
  const bool res = core_solver.check( complete );
#if EXTERNAL_TOOL
  if ( complete) verifyCallWithExternalTool( res, trail.size( ) - 1 );
#endif
  core_solver.checkEmptyExpl( );

  return res;
}

void THandler::backtrack( )
{
  // Undoes the state of theory atoms if needed
  while ( (int)stack.size( ) > trail.size( ) )
  {
    Enode * e = stack.back( );
    stack.pop_back( );

    // It was var_True or var_False
    if ( e == NULL )
      continue;

    if ( !e->isTAtom( ) )
      continue;

    core_solver.popBacktrackPoint( );
    assert( e->isTAtom( ) );
    assert( e->hasPolarity( ) );
    assert( e->getPolarity( ) == l_True
	 || e->getPolarity( ) == l_False );
    // Reset polarity
    e->resetPolarity( );
  }
  checked_trail_size = stack.size( );
}

//
// Return the conflict generated by a theory solver
//
void THandler::getConflict ( vec< Lit > & conflict, int & max_decision_level )
{
  // First of all, the explanation in a tsolver is
  // stored as conjunction of enodes e1,...,en
  // with associated polarities p1,...,pn. Since the sat-solver
  // wants a clause we store it in the form ( l1 | ... | ln )
  // where li is the literal corresponding with ei with polarity !pi
  vector< Enode * > & explanation = core_solver.getConflict( );
  assert( !explanation.empty( ) );

#if EXTERNAL_TOOL
  verifyExplanationWithExternalTool( explanation );
#endif

  max_decision_level = -1;
  while ( !explanation.empty( ) )
  {
    Enode * ei  = explanation.back( );
    explanation.pop_back( );
    assert( ei->hasPolarity( ) );
    assert( ei->getPolarity( ) == l_True
	 || ei->getPolarity( ) == l_False );
    bool negate = ei->getPolarity( ) == l_False;

    Var v = enodeToVar( ei );
#if PEDANTIC_DEBUG
    assert( isOnTrail( Lit( v, negate ) ) );
#endif
    Lit l = Lit( v, !negate );
    conflict.push( l );

    if ( max_decision_level < level[ v ] )
      max_decision_level = level[ v ];
  }
}

Lit THandler::getDeduction( )
{
  Enode * e = core_solver.getDeduction( );

  if ( e == NULL )
    return lit_Undef;

#if EXTERNAL_TOOL
  verifyDeductionWithExternalTool( e );
#endif

  assert( e->isDeduced( ) );
  assert( e->getDeduced( ) == l_False
       || e->getDeduced( ) == l_True );
  bool negate = e->getDeduced( ) == l_False;
  Var v = enodeToVar( e );
  return Lit( v, negate );
}

Lit THandler::getSuggestion( )
{
  Enode * e = core_solver.getSuggestion( );

  if ( e == NULL )
    return lit_Undef;

  bool negate = e->getDecPolarity( ) == l_False;
  Var v = enodeToVar( e );
  return Lit( v, negate );
}

void THandler::getReason( Lit l, vec< Lit > & reason )
{
#if LAZY_COMMUNICATION
  assert( checked_trail_size == (int)stack.size( ) );
  assert( checked_trail_size == (int)trail.size( ) );
#else
#endif

  Var v = var(l);
  Enode * e = varToEnode( v );

  // It must be a TAtom and already disabled
  assert( e->isTAtom( ) );
  assert( !e->hasPolarity( ) );
  assert( e->isDeduced( ) );
  assert( e->getDeduced( ) != l_Undef );           // Last assigned deduction
#if LAZY_COMMUNICATION
  assert( e->getPolarity( ) != l_Undef );          // Last assigned polarity
  assert( e->getPolarity( ) == e->getDeduced( ) ); // The two coincide
#else
#endif

  core_solver.pushBacktrackPoint( );

  // Assign reversed polarity temporairly
  e->setPolarity( e->getDeduced( ) == l_True ? l_False : l_True );
  // Compute reason in whatever solver
  const bool res = core_solver.assertLit( e, true ) &&
                   core_solver.check( true );
  // Result must be false
#ifdef SMTCOMP
  //
  // This is a critical condition that should not happen
  // Still for one instance (out of ALL) it shows up.
  // We prefer to return unknown instead of letting the
  // solver to run in an incorrect state ...
  //
  if ( res )
  {
    cout << endl << "unknown" << endl;
    exit( 1 );
  }
#else
  assert( !res );
#endif

  // Get Explanation
  vector< Enode * > & explanation = core_solver.getConflict( true );

#if EXTERNAL_TOOL
  verifyExplanationWithExternalTool( explanation );
#endif

  // Reserve room for implied lit
  reason.push( lit_Undef );
  // Copy explanation

  while ( !explanation.empty( ) )
  {
    Enode * ei  = explanation.back( );
    explanation.pop_back( );
    assert( ei->hasPolarity( ) );
    assert( ei->getPolarity( ) == l_True
	 || ei->getPolarity( ) == l_False );
    bool negate = ei->getPolarity( ) == l_False;
    Var v = enodeToVar( ei );

    // Toggle polarity for deduced literal
    if ( e == ei )
    {
      assert( e->getDeduced( ) != l_Undef );           // But still holds the deduced polarity
      // The deduced literal must have been pushed
      // with the the same polarity that has been deduced
      reason[ 0 ] = Lit( v, !negate );
    }
    else
    {
      assert( ei->hasPolarity( ) );                    // Lit in explanation is active
      // This assertion might fail if in your theory solver
      // you do not skip deduced literals during assertLit
      //
      // TODO: check ! It could be deduced: by another solver
      // For instance BV found conflict and ei was deduced by EUF solver
      //
      // assert( !ei->isDeduced( ) );                     // and not deduced
      Lit l = Lit( v, !negate );
      reason.push( l );
    }
  }

  core_solver.popBacktrackPoint( );

  // Resetting polarity
  e->resetPolarity( );
}

#ifdef PEDANTIC_DEBUG
bool THandler::isOnTrail( Lit l )
{
  for ( unsigned i = 0 ; i < trail.size( ) ; i ++ )
    if ( trail[ i ] == l ) return true;

  return false;
}
#endif

#ifdef EXTERNAL_TOOL
void THandler::verifyCallWithExternalTool( bool res, size_t trail_size )
{
  // First stage: print declarations
  const char * name = "/tmp/verifycall.smt";
  std::ofstream dump_out( name );

  core_solver.dumpHeaderToFile( dump_out );

  dump_out << ":formula" << endl;
  dump_out << "(and" << endl;
  for ( size_t j = 0 ; j <= trail_size ; j ++ )
  {
    Var v = var( trail[ j ] );

    if ( v == var_True || v == var_False )
      continue;

    Enode * e = var_to_enode[ v ];
    assert( e );

    if ( !e->isTAtom( ) )
      continue;

    bool negated = sign( trail[ j ] );
    if ( negated )
      dump_out << "(not ";
    e->print( dump_out );
    if ( negated )
      dump_out << ")";

    dump_out << endl;
  }
  dump_out << "))" << endl;
  dump_out.close( );

  // Second stage, check the formula
  bool tool_res;

  if ( int pid = fork() )
  {
    int status;
    waitpid(pid, &status, 0);
    switch ( WEXITSTATUS( status ) )
    {
      case 0:
	tool_res = false;
	break;
      case 1:
	tool_res = true;
	break;
      default:
	perror( "Tool" );
	exit( EXIT_FAILURE );
    }
  }
  else
  {
    execlp( "tool_wrapper.sh", "tool_wrapper.sh", name, 0 );
    perror( "Tool" );
    exit( EXIT_FAILURE );
  }

  if ( res == false && tool_res == true )
  {
    cerr << "tool: sat stack" << endl;
    exit( 1 );
  }
  if ( res == true && tool_res == false )
  {
    cerr << "tool: unsat stack" << endl;
    exit( 1 );
  }
}

void THandler::verifyExplanationWithExternalTool( vector< Enode * > & expl )
{
  // First stage: print declarations
  const char * name = "/tmp/verifyexp.smt";
  std::ofstream dump_out( name );

  core_solver.dumpHeaderToFile( dump_out );

  dump_out << ":formula" << endl;
  dump_out << "(and" << endl;

  for ( size_t j = 0 ; j < expl.size( ) ; j ++ )
  {
    Enode * e = expl[ j ];
    assert( e->isTAtom( ) );
    assert( e->getPolarity( ) != l_Undef );
    bool negated = e->getPolarity( ) == l_False;
    if ( negated )
      dump_out << "(not ";
    e->print( dump_out );
    if ( negated )
      dump_out << ")";

    dump_out << endl;
  }

  dump_out << "))" << endl;
  dump_out.close( );
  // Third stage, check the formula
  bool tool_res;

  if ( int pid = fork() )
  {
    int status;
    waitpid(pid, &status, 0);
    switch ( WEXITSTATUS( status ) )
    {
      case 0:
	tool_res = false;
	break;
      case 1:
	tool_res = true;
	break;
      default:
	perror( "Tool" );
	exit( EXIT_FAILURE );
    }
  }
  else
  {
    execlp( "tool_wrapper.sh", "tool_wrapper.sh", name, 0 );
    perror( "Tool" );
    exit( 1 );
  }

  if ( tool_res == true )
    error( "external tool says this is not an explanation", "" );
}

void THandler::verifyDeductionWithExternalTool( Enode * imp )
{
  assert( imp->isDeduced( ) );

  // First stage: print declarations
  const char * name = "/tmp/verifydeduction.smt";
  std::ofstream dump_out( name );

  core_solver.dumpHeaderToFile( dump_out );

  dump_out << ":formula" << endl;
  dump_out << "(and" << endl;
  for ( int j = 0 ; j < trail.size( ) ; j ++ )
  {
    Var v = var( trail[ j ] );

    if ( v == var_True || v == var_False )
      continue;

    Enode * e = var_to_enode[ v ];
    assert( e );

    if ( !e->isTAtom( ) )
      continue;

    bool negated = sign( trail[ j ] );
    if ( negated )
      dump_out << "(not ";
    e->print( dump_out );
    if ( negated )
      dump_out << ")";

    dump_out << endl;
  }

  if ( imp->getDeduced( ) == l_True )
    dump_out << "(not " << imp << ")" << endl;
  else
    dump_out << imp << endl;

  dump_out << "))" << endl;
  dump_out.close( );

  // Second stage, check the formula
  bool tool_res;

  if ( int pid = fork() )
  {
    int status;
    waitpid(pid, &status, 0);
    switch ( WEXITSTATUS( status ) )
    {
      case 0:
	tool_res = false;
	break;
      case 1:
	tool_res = true;
	break;
      default:
	perror( "Tool" );
	exit( EXIT_FAILURE );
    }
  }
  else
  {
    execlp( "tool_wrapper.sh", "tool_wrapper.sh", name, 0 );
    perror( "Tool" );
    exit( EXIT_FAILURE );
  }

  if ( tool_res )
  {
    cerr << "tool: not a valid deduction" << endl;
    exit( 1 );
  }
}
#endif
