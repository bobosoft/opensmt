/*********************************************************************
Author: Roberto Bruttomesso <roberto.bruttomesso@unisi.ch>

OpenSMT -- Copyright (C) 2008, Roberto Bruttomesso

OpenSMT is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenSMT is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenSMT. If not, see <http://www.gnu.org/licenses/>.
*********************************************************************/

#include "THandler.h"

#ifdef EXTERNAL_TOOL
#include <sys/wait.h>
#endif

//
// Return the MiniSAT Variable corresponding to
// the positive input enode. Creates the correspondence
// by adding a new MiniSAT variable, if it doesn't exists 
//
Var THandler::enodeToVar( Enode * atm )
{
  assert( atm );
  assert( atm->isAtom( ) );
  assert( !atm->isTrue( ) );
  assert( !atm->isFalse( ) );

  if ( enode_id_to_var.size( ) <= (unsigned)atm->getId( ) )
    enode_id_to_var.resize( atm->getId( ) + 1, var_Undef );

  Var v = enode_id_to_var[ atm->getId( ) ];

  if ( v == var_Undef )
  {
    // There is no variable in MiniSAT for this enode
    // Create a new variable and store the correspondence
    v = solver.newVar( );
    enode_id_to_var[ atm->getId( ) ] = v;

    // Inform core solver about the existence of this atom
    if ( atm->isTAtom( ) )
	core_solver.inform( atm );

    if ( var_to_enode.size( ) <= (unsigned)v )
      var_to_enode.resize( v + 1, NULL );

    assert( var_to_enode[ v ] == NULL );
    var_to_enode[ v ] = atm;
  }

  return v;
}

//
// Return the MiniSAT literal corresponding to
// the input enode literal. Creates the correspondence
// by adding a new MiniSAT variable, if it doesn't exists 
//
Lit THandler::enodeToLit( Enode * elit )
{
  assert( elit );
  assert( elit->isLit( ) );

  bool negated = elit->isNot( );
  Enode * atm = negated ? elit->getCdr( )->getCar( ) : elit;
  Var v = enodeToVar( atm );

  return Lit( v, negated );
}

Enode * THandler::varToEnode( Var v )
{
  assert( v < (int)var_to_enode.size( ) );
  assert( var_to_enode[ v ] != NULL );

  return var_to_enode[ v ];
}

bool THandler::assertLits( )
{
  bool res = true;

  for ( size_t i = checked_trail_size ; i < trail.size( ) && res ; i ++ )
  {
    const Lit l = trail[ i ];
    const Var v = var( l );
    const int lev = level[ v ];

    if ( (int)level_to_stack_size.size( ) < lev + 1 )
      level_to_stack_size.resize( lev + 1, stack.size( ) );
    level_to_stack_size[ lev ] ++;

    Enode * e = var_to_enode[ v ];
    stack.push_back( e );

    if ( !e->isTAtom( ) )
      continue;
    
    // Push backtrack point 
    core_solver.pushBacktrackPoint( );

    assert( e->getPolarity( ) == l_Undef );
    e->setPolarity( (sign( l ) ? l_False : l_True) );
    res = core_solver.assertLit( e ); 

    // Invariant: OK there are 3 cases:
    // 1. e hasn't been deduced
    // 2. e has been deduced with the same polarity it has been pushed: 
    //    then the result must be true
    // 3. otherwise the result must be false
    assert( e->getDeduced( ) == l_Undef 
	 || ( e->getDeduced( ) == e->getPolarity( ) && res )
         || !res );

#ifdef EXTERNAL_TOOL
    verifyCallWithExternalTool( res, i );
#endif
  }

  checked_trail_size = trail.size( );

  return res;
}

bool THandler::check( bool complete )
{
  return core_solver.check( complete );
}

void THandler::backtrack( int blevel )
{
  assert( blevel >= -1 );

  if ( level_to_stack_size.size( ) == 0 )
    return;

  assert( blevel < (int)level_to_stack_size.size( ) );

  if ( checked_trail_size > trail.size( ) )
    checked_trail_size = trail.size( );

  size_t new_size = 0;

  if ( blevel != -1 )
    new_size = level_to_stack_size[ blevel ];

  level_to_stack_size.resize( blevel + 1 );
  assert( blevel + 1 == (int)level_to_stack_size.size( ) );
  backtrackToStackSize( new_size );
}

//
// Return the conflict generated by a theory solver
//
void THandler::getConflict ( vec< Lit > & conflict, int & max_decision_level )
{
  // First of all, the explanation in a tsolver is
  // stored as conjunction of enodes e1,...,en
  // with associated polarities p1,...,pn. Since the sat-solver
  // wants a clause we store it in the form ( l1 | ... | ln )
  // where li is the literal corresponding with ei with polarity !pi
  vector< Enode * > & explanation = core_solver.getConflict( );

#if EXTERNAL_TOOL
  verifyExplanationWithExternalTool( explanation );
#endif

  max_decision_level = -1;
  while ( !explanation.empty( ) ) 
  {
    Enode * ei  = explanation.back( );
    explanation.pop_back( );
    assert( ei->getPolarity( ) == l_True 
	 || ei->getPolarity( ) == l_False );
    bool negate = ei->getPolarity( ) == l_False;
    Var v = enodeToVar( ei );
#if PEDANTIC_DEBUG
    assert( isOnTrail( Lit( v, negate ) ) );
#endif
    Lit l = Lit( v, !negate );
    conflict.push( l );

    if ( max_decision_level < level[ v ] )
      max_decision_level = level[ v ];
  }
}

Lit THandler::getDeduction( )
{
  Enode * e = core_solver.getDeduction( );

  if ( e == NULL )
    return lit_Undef;

  assert( e->getDeduced( ) == l_False 
       || e->getDeduced( ) == l_True );
  bool negate = e->getDeduced( ) == l_False;
  Var v = enodeToVar( e );
  return Lit( v, negate );
}

void THandler::getReason( Lit l, vec< Lit > & reason )
{
  Var v = var(l);
  Enode * e = varToEnode( v );

  // First of all we have to backtrack the solvers up to
  // the state that originated the deduction. This is important
  // because a deduction in our framework must be expressed in terms 
  // of atoms that have been pushed before the deduced one, in the
  // same way as happen for theory propagation. This is not bad, though
  // as getReason is called only during conflict analysis: we would
  // have to backtrack to this state anyways. Later popBacktrackPoint
  // might produce no effect, as the stack has been already popped a little bit
  core_solver.popUntilDeduced( e );
  // Explain why e is deduced in the current context
  // First of all, the explanation in a tsolver is
  // stored as conjunction of enodes e1,...,en
  // with associated polarities p1,...,pn. Since the sat-solver
  // wants a clause we store it in the form ( l1 | ... | ln )
  // where li is the literal corresponding with ei with polarity !pi
  vector< Enode * > & explanation = core_solver.getReason( e );

#if EXTERNAL_TOOL
  verifyExplanationWithExternalTool( explanation, e );
#endif

  // Reserve room for implied lit
  reason.push( lit_Undef );
  // Copy explanation
  while ( !explanation.empty( ) ) 
  {
    Enode * ei  = explanation.back( );
    explanation.pop_back( );
    assert( ei->getPolarity( ) == l_True
	 || ei->getPolarity( ) == l_False ); 
    bool negate = ei->getPolarity( ) == l_False;
    Var v = enodeToVar( ei );

    // Toggle polarity for deduced literal
    if ( e == ei )
    {
      assert( e->getDeduced( ) != l_Undef );
      // The deduced literal must have been pushed 
      // with the the same polarity that has been deduced
      assert( e->getDeduced( ) == e->getPolarity( ) );
      reason[ 0 ] = Lit( v, negate );
    }
    else
    {
      assert( ei->getDeduced( ) == l_Undef );
      Lit l = Lit( v, !negate );
      reason.push( l );
    }
  }
}

void THandler::backtrackToStackSize( size_t new_size )
{
  // Undoes the state of theory atoms
  while ( stack.size( ) > new_size )
  {
    Enode * e = stack.back( );
    stack.pop_back( );

    if ( !e->isTAtom( ) )
      continue;

    core_solver.popBacktrackPoint( );
    assert( e->isTAtom( ) );
    assert( e->getPolarity( ) == l_True 
	 || e->getPolarity( ) == l_False );
    // Reset polarity
    e->setPolarity( l_Undef );
    e->setDeduced( l_Undef, -2 );
  }
}

#ifdef PEDANTIC_DEBUG
bool THandler::isOnTrail( Lit l )
{
  for ( unsigned i = 0 ; i < trail.size( ) ; i ++ )
    if ( trail[ i ] == l ) return true; 

  return false;
}
#endif

#ifdef EXTERNAL_TOOL
void THandler::verifyCallWithExternalTool( bool res, size_t trail_size )
{
  // First stage: print declarations
  const char * name = "/tmp/verifycall.smt";
  std::ofstream temp_out( name );
  temp_out << "(benchmark temp_call" << endl;
  temp_out << ":logic QF_UF" << endl;
  temp_out << ":extrasorts (I)" << endl;
  set< int > declaredStuff;
  for ( int j = 0 ; j <= trail_size ; j ++ )
  {
    Var v = var( trail[ j ] );
    Enode * e = var_to_enode[ v ];

    if ( !e->isTAtom( ) )
      continue;

    if ( e->getPolarity( ) == l_Undef )
    {
      cerr << "Error: atom " << e << " has undefined polarity" << endl;
      for ( int j = 0 ; j < trail.size( ) ; j ++ )
      {
	Var v = var( trail[ j ] );
	int l = level[ v ];
	Enode * e = var_to_enode[ v ];
	cerr << "[" << l << "] " << (sign(trail[j])?"!":" ") << e << endl;
      }

      exit( 1 );
    }

    assert( e->getPolarity( ) != l_Undef );

    declareStuff( temp_out, declaredStuff, e );
  }
  // Second stage, prints out formula
  temp_out << ":formula" << endl;
  temp_out << "(and" << endl;
  for ( int j = 0 ; j <= trail_size ; j ++ )
  {
    Var v = var( trail[ j ] );
    Enode * e = var_to_enode[ v ];

    if ( !e->isTAtom( ) )
      continue;

    bool negated = sign( trail[ j ] );
    if ( negated )
      temp_out << "(not ";
    e->print( temp_out );
    if ( negated )
      temp_out << ")";

    temp_out << endl;
  }
  temp_out << "))" << endl;
  temp_out.close( );
  // Third stage, check the formula
  bool tool_res;

  if ( int pid = fork() )
  {
    int status;
    waitpid(pid, &status, 0);
    switch ( WEXITSTATUS( status ) )
    {
      case 0:
	tool_res = false;
	break;
      case 1:
	tool_res = true;
	break;
      default:
	perror( "Tool" );
	exit( EXIT_FAILURE ); 
    }
  }
  else
  {
    execlp( "tool_wrapper.sh", "tool_wrapper.sh", name, 0 );
    perror( "Tool" );
    exit( EXIT_FAILURE );
  }

  if ( res == false && tool_res == true )
  {
    cerr << "tool: true" << endl;
    exit( 1 );
  }
  if ( res == true && tool_res == false )
  {
    cerr << "tool: false" << endl;
    exit( 1 );
  }
}

void THandler::verifyExplanationWithExternalTool( vector< Enode * > & expl, Enode * imp )
{
  // First stage: print declarations
  const char * name = "/tmp/verifyexp.smt";
  std::ofstream temp_out( name );
  temp_out << "(benchmark temp_call" << endl;
  temp_out << logicStr( config.logic ) << endl;
  temp_out << ":extrasorts (I)" << endl;
  set< int > declaredStuff;
  for ( int j = 0 ; j < expl.size( ) ; j ++ )
  {
    Enode * e = expl[ j ];

    if ( !e->isTAtom( ) )
      continue;

    if ( e->getPolarity( ) == l_Undef )
    {
      cerr << "Error: atom " << e << " has undefined polarity" << endl;
      exit( 1 );
    }

    assert( e->getPolarity( ) != l_Undef );

    declareStuff( temp_out, declaredStuff, e );
  }
  // Second stage, prints out formula
  temp_out << ":formula" << endl;
  temp_out << "(and" << endl;

  for ( int j = 0 ; j < expl.size( ) ; j ++ )
  {
    Enode * e = expl[ j ];
    assert( e->isTAtom( ) );
    assert( e->getPolarity( ) != l_Undef );
    bool negated = e->getPolarity( ) == l_False;
    if ( e == imp )
      negated = !negated;
    if ( negated )
      temp_out << "(not ";
    e->print( temp_out );
    if ( negated )
      temp_out << ")";

    temp_out << endl;
  }

  temp_out << "))" << endl;
  temp_out.close( );
  // Third stage, check the formula
  bool tool_res;

  if ( int pid = fork() )
  {
    int status;
    waitpid(pid, &status, 0);
    switch ( WEXITSTATUS( status ) )
    {
      case 0:
	tool_res = false;
	break;
      case 1:
	tool_res = true;
	break;
      default:
	perror( "Tool" );
	exit( EXIT_FAILURE ); 
    }
  }
  else
  {
    execlp( "tool_wrapper.sh", "tool_wrapper.sh", name, 0 );
    perror( "Tool" );
    exit( EXIT_FAILURE );
  }

  if ( tool_res == true )
  {
    cerr << "Error: tool says this is not an explanation" << endl;
    exit( 1 );
  }
}

void THandler::declareStuff( ostream & temp_out, set< int > & declaredStuff, Enode * e )
{
  if ( declaredStuff.find( e->getId( ) ) != declaredStuff.end( ) )
    return;

  if ( e->isEnil( ) )
    return;

  if ( e->isTerm( ) || e->isList( ) )
  {
    declareStuff( temp_out, declaredStuff, e->getCar( ) );
    declareStuff( temp_out, declaredStuff, e->getCdr( ) );
  }
  else if ( e->isSymb( ) && e->getId( ) > ENODE_ID_LAST )
  {
    if ( e->getType( ) == TYPE_BOOL )
    {
      temp_out << ":extrapreds(( " << e->getName( );
    }
    else
    {
      temp_out << ":extrafuns(( " << e->getName( );
    }
    for ( char i = 0 ; i < (e->getType( ) == TYPE_BOOL ? e->getArity( ) : e->getArity( ) + 1) ; i ++ )
    {
      if ( e->getType( ) == TYPE_U )
	temp_out << " U";
      else 
	temp_out << " I";
    }
    temp_out << " ))";
    temp_out << endl;
    declaredStuff.insert( e->getId( ) );
  }
}
#endif
